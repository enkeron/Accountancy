CLOSE DATABASES all
CLOSE TABLES all
RELEASE ALL EXTENDED
CLEAR ALL
PUSH MENU _MSYSMENU

SET ENGINEBEHAVIOR 70
SET EXACT ON

SET SAFETY OFF
SET NOTIFY OFF

SET REPROCESS TO AUTOMATIC
SET MULTILOCKS ON
SET TALK OFF
SET DELETED ON

ON SHUTDOWN QUIT
POP MENU _MSYSMENU

*DO FORM f_main NAME fMain LINKED 
*READ EVENTS
 
RESTORE FROM enterprise ADDITIVE 

DO FORM f_result NAME result LINKED 
READ EVENTS

*-----------------------------
PROCEDURE p_error
	MESSAGEBOX(PROGRAM())
ENDPROC

*-------------------------------------
PROCEDURE P_FILL_GRID(loGrid,lsCursor)
*-------------------------------------
*заполнить грид
	loGrid.RecordSource = lsCursor
	FOR EACH loCl IN loGrid.Columns
		loCl.ControlSource=lsCursor + "." + SUBSTR(loCl.Name,3)
	ENDFOR
ENDPROC

**************************************************************
FUNCTION WriteIniFile (lsIniFileName, cTask, cValName, cValue)
**************************************************************
 * писАть в ini. файл
  IF File(lsIniFileName) 
    DECLARE INTEGER WritePrivateProfileString IN Win32API AS WritePrivStr ;
      String cSection, String cKey, String cValue, String cINIFile
    WritePrivStr(cTask, cValName, cValue, lsIniFileName)
    CLEAR DLLS WritePrivStr
  ENDIF 
ENDFUNC 

****************************************************
FUNCTION ReadIniFile(lsIniFileName, cTask, cValName)
****************************************************
* читать из ini. файла
  LOCAL vRetValue,lcBuffer,lnSumbol
  vRetValue=""
  IF File(lsIniFileName) 
    DECLARE INTEGER GetPrivateProfileString IN Win32API  AS GetPrivStr ;
      String cSection, String cKey, String cDefault, String @cBuffer, ;
      Integer nBufferSize, String cINIFile
    lcBuffer = SPACE(300)   && определяется размер буфера
    lnSumbol = GetPrivStr(cTask, cValName, " ", @lcBuffer,;
      LEN(lcBuffer), lsIniFileName)
    vRetValue = SUBSTR(lcBuffer, 1, lnSumbol)
  ENDIF 
    CLEAR DLLS GetPrivStr
    RETURN vRetValue
ENDFUNC

*********************************
DEFINE CLASS menulib AS container
*********************************
  Width = 50
  Height = 15
  Visible = .F.
  BackColor = RGB(0,0,255)
  Name = "menulib"

******************
PROCEDURE showmenu
******************
	LPARAMETERS taMenu,nX,nY
		nX=IIF(EMPTY(nX),MCOL(),nX)
		nY=IIF(EMPTY(nY),MROW(),nY)

	LOCAL lnMenuCount,lnCount,lcMenuItem,lcPic,lcSkip,lcA
	EXTERNAL ARRAY taMenu

    IF PARAMETERS()=0 OR TYPE("taMenu")#"C"
      RETURN .F.
    ENDIF

    lnMenuCount=0
    lnMenuCount=ALEN(taMenu,1)

    IF lnMenuCount=0
      RETURN .F.
    ENDIF
    DEACTIVATE POPUP _popShortcutMenu
    DEFINE POPUP _popShortcutMenu ;
        FROM nY,nX ;
        MARGIN ;
        RELATIVE ;
        SHORTCUT

    FOR lnCount = 1 TO lnMenuCount
      lcMenuItem=taMenu[lnCount,1]
      
        lcPic=IIF(VARTYPE(taMenu[lnCount,3])="U" OR EMPTY(taMenu[lnCount,3]),""," PICTURE '"+ALLTRIM(taMenu[lnCount,3])+"'")
        lcSkip=IIF(VARTYPE(taMenu[lnCount,4])="U" OR EMPTY(taMenu[lnCount,4]),""," SKIP FOR "+ALLTRIM(taMenu[lnCount,4]))
     	lcA=lcPic+lcSkip
     	DEFINE BAR lnCount OF _popShortcutMenu PROMPT lcMenuItem &lcA

    ENDFOR

    ON SELECTION POPUP _popShortcutMenu DEACTIVATE POPUP _popShortcutMenu
    ACTIVATE POPUP _popShortcutMenu
    RELEASE POPUP _popShortcutMenu
    IF BAR()=0
      RETURN .F.
    ENDIF
ENDPROC

PROCEDURE deactivatemenu
  DEACTIVATE MENU _popShortcutMenu
ENDPROC

PROCEDURE Destroy
    
ENDPROC

 * Формируем идентификатор данного приложения  
  LOCAL lcApplicationName  
  lcApplicationName = GetEnv("SessionName") + "#"+ SYS(0)  
    
 * Формируем ссылку на объект Mutex  
  Declare Integer CreateMutex In Win32API ;  
  	Integer lpMutexAttributes, ;  
  	Integer bInitialOwner, ;  
  	String lpName  
    
  PUBLIC gnMutex  
  gnMutex = CreateMutex(0,1,m.lcApplicationName)  
    
 * Проверяем факт существования объекта Mutex с тем же именем  
  #DEFINE ERROR_ALREADY_EXISTS 183  
  Declare integer GetLastError In Win32API  
    
  If GetLastError() = ERROR_ALREADY_EXISTS  
 	* Приложение уже запущено  
 	* Надо вывести ранее запущенное приложение на передний план  
 	* или сообщить об этом факте пользователю  
 	* и закрыть текущее приложение  
  	Do CloseMutex with .T.  
  	Return  
  EndIf  
    
 * Если объект Mutex был именно создан, то нет ранее запущенного приложения   
 * и можно запускать текущее приложение  
    
  ...  
  READ EVENTS  
    
 * По окончании работы приложения надо удалить объект Mutex, хотя это и не обязательно  
  Do CloseMutex with .F.  
  Return  
    
 * Процедура удаления объекта Mutex  
  Procedure CloseMutex  
  LParameters IsExists	&& существует ли другое приложение  
    
 * Если другое приложение существует, то удалять объект Mutex не надо  
 * Удаление выполняется только если объект был создан именно в этом приложении  
  If IsExists = .f.  
 	* Удаление объекта Mutex  
  	Declare integer ReleaseMutex IN Win32API Integer hMutex  
  	ReleaseMutex(m.gnMutex)  
  EndIf  
    
 * Закрытие уже не нужного хендла объекта Mutex  
  Declare integer CloseHandle IN Kernel32 Integer hObject  
  CloseHandle(m.gnMutex)  
    
  EndProc
ENDDEFINE

